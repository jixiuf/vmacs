From f88122c5ee859bb9257d4c501eb2a2ceb2efd981 Mon Sep 17 00:00:00 2001
From: Isaac Mills <rooster0055@protonmail.com>
Date: Sat, 5 Jul 2025 12:35:50 -0600
Subject: [PATCH 1/3] Implement a four-finger swipe gesture to do an
 interactive move of the focused window

---
 src/handlers/xdg_shell.rs |  26 +++++-
 src/input/mod.rs          | 172 +++++++++++++++++++++++++++++++++-----
 src/input/move_grab.rs    | 118 +++++++++++++++++++++++---
 src/niri.rs               |   9 +-
 4 files changed, 288 insertions(+), 37 deletions(-)

diff --git a/src/handlers/xdg_shell.rs b/src/handlers/xdg_shell.rs
index 171b65fd..9b44b3bb 100644
--- a/src/handlers/xdg_shell.rs
+++ b/src/handlers/xdg_shell.rs
@@ -132,15 +132,37 @@ impl XdgShellHandler for State {
         let window = mapped.window.clone();
         let output = output.clone();
 
+        let output_pos = self
+            .niri
+            .global_space
+            .output_geometry(&output)
+            .unwrap()
+            .loc
+            .to_f64();
+
+        let pos_within_output = start_data.location() - output_pos;
+
+        if !self
+            .niri
+            .layout
+            .interactive_move_begin(window.clone(), &output, pos_within_output)
+        {
+            return;
+        }
+
         match &start_data {
             PointerOrTouchStartData::Pointer(_) => {
-                if let Some(grab) = MoveGrab::new(self, start_data, window.clone(), true) {
+                if let Some(grab) =
+                    MoveGrab::new(self, start_data, window.clone(), true, false, false)
+                {
                     pointer.set_grab(self, grab, serial, Focus::Clear);
                 }
             }
             PointerOrTouchStartData::Touch(_) => {
                 let touch = self.niri.seat.get_touch().unwrap();
-                if let Some(grab) = MoveGrab::new(self, start_data, window.clone(), true) {
+                if let Some(grab) =
+                    MoveGrab::new(self, start_data, window.clone(), true, false, false)
+                {
                     touch.set_grab(self, grab, serial);
                 }
             }
diff --git a/src/input/mod.rs b/src/input/mod.rs
index 81e5d863..c10c7948 100644
--- a/src/input/mod.rs
+++ b/src/input/mod.rs
@@ -108,6 +108,61 @@ impl<D: SeatHandler> PointerOrTouchStartData<D> {
     }
 }
 
+#[derive(PartialEq, Eq, Clone, Copy)]
+enum SwipeDirection {
+    Horizontal,
+    Vertical,
+    Unknown,
+    Undecided,
+}
+
+pub struct SwipeDirectionDecider {
+    cx: f64,
+    cy: f64,
+    decision: SwipeDirection,
+}
+
+impl SwipeDirectionDecider {
+    pub fn decided() -> Self {
+        Self {
+            cx: 0.,
+            cy: 0.,
+            decision: SwipeDirection::Unknown,
+        }
+    }
+
+    fn undecided() -> Self {
+        Self {
+            cx: 0.,
+            cy: 0.,
+            decision: SwipeDirection::Undecided,
+        }
+    }
+
+    fn update_and_maybe_decide(&mut self, delta_x: f64, delta_y: f64) -> Option<SwipeDirection> {
+        if self.decision != SwipeDirection::Undecided {
+            return None;
+        }
+
+        self.cx += delta_x;
+        self.cy += delta_y;
+
+        // Check if the gesture moved far enough to decide. Threshold copied from GNOME Shell.
+        if self.cx * self.cx + self.cy * self.cy >= 16. * 16. {
+            self.decision = if self.cx.abs() > self.cy.abs() {
+                SwipeDirection::Horizontal
+            } else {
+                SwipeDirection::Vertical
+            };
+
+            Some(self.decision)
+        } else {
+            // Undecided, needs more data (movement)
+            None
+        }
+    }
+}
+
 impl State {
     pub fn process_input_event<I: InputBackend + 'static>(&mut self, event: InputEvent<I>)
     where
@@ -2851,15 +2906,24 @@ impl State {
                             self.niri.layout.activate_window(&window);
                         }
 
+                        // if self.niri.layout.interactive_move_begin(
+                        //     window.clone(),
+                        //     &output,
+                        //     pos_within_output,
+                        // ) {
                         let start_data = PointerGrabStartData {
                             focus: None,
                             button: button_code,
                             location,
                         };
+
                         let start_data = PointerOrTouchStartData::Pointer(start_data);
-                        if let Some(grab) = MoveGrab::new(self, start_data, window.clone(), false) {
+                        if let Some(grab) =
+                            MoveGrab::new(self, start_data, window.clone(), false, false, false)
+                        {
                             pointer.set_grab(self, grab, serial, Focus::Clear);
                         }
+                        // }
                     }
                 }
                 // Check if we need to start an interactive resize.
@@ -3696,13 +3760,12 @@ impl State {
         }
 
         if event.fingers() == 3 {
-            self.niri.gesture_swipe_3f_cumulative = Some((0., 0.));
+            self.niri.gesture_swipe_3f_decider = SwipeDirectionDecider::undecided();
 
             // We handled this event.
             return;
         } else if event.fingers() == 4 {
-            self.niri.layout.overview_gesture_begin();
-            self.niri.queue_redraw_all();
+            self.niri.gesture_swipe_4f_decider = SwipeDirectionDecider::undecided();
 
             // We handled this event.
             return;
@@ -3753,17 +3816,14 @@ impl State {
 
         let is_overview_open = self.niri.layout.is_overview_open();
 
-        if let Some((cx, cy)) = &mut self.niri.gesture_swipe_3f_cumulative {
-            *cx += delta_x;
-            *cy += delta_y;
-
-            // Check if the gesture moved far enough to decide. Threshold copied from GNOME Shell.
-            let (cx, cy) = (*cx, *cy);
-            if cx * cx + cy * cy >= 16. * 16. {
-                self.niri.gesture_swipe_3f_cumulative = None;
-
-                if let Some(output) = self.niri.output_under_cursor() {
-                    if cx.abs() > cy.abs() {
+        if let Some(descision) = self
+            .niri
+            .gesture_swipe_3f_decider
+            .update_and_maybe_decide(delta_x, delta_y)
+        {
+            if let Some(output) = self.niri.output_under_cursor() {
+                match descision {
+                    SwipeDirection::Horizontal => {
                         let output_ws = if is_overview_open {
                             self.niri.workspace_under_cursor(true)
                         } else {
@@ -3781,12 +3841,70 @@ impl State {
                                 .layout
                                 .view_offset_gesture_begin(&output, Some(ws_idx), true);
                         }
-                    } else {
+                    }
+                    SwipeDirection::Vertical => {
                         self.niri
                             .layout
                             .workspace_switch_gesture_begin(&output, true);
                     }
+                    _ => {}
+                }
+            }
+        }
+
+        if let Some(descision) = self
+            .niri
+            .gesture_swipe_4f_decider
+            .update_and_maybe_decide(delta_x, delta_y)
+        {
+            match descision {
+                SwipeDirection::Horizontal => {
+                    if let Some((active_window, pos_within_output)) =
+                        self.niri.layout.active_workspace().and_then(|w| {
+                            Some((w.active_window()?.id(), w.active_tile_visual_rectangle()?))
+                        })
+                    {
+                        let window = {
+                            let mut windows = self.niri.layout.windows();
+                            windows
+                                .find(|(_, m)| m.id() == active_window)
+                                .and_then(|(m, a)| Some((m?, a)))
+                                .map(|(monitor, active_window)| {
+                                    (monitor.output().clone(), active_window.window.clone())
+                                })
+                        };
+                        if let Some((output, active_window)) = window {
+                            let location = pos_within_output.loc + (pos_within_output.size / 2.0);
+                            if self.niri.layout.interactive_move_begin(
+                                active_window.clone(),
+                                &output,
+                                location,
+                            ) {
+                                let start_data = PointerGrabStartData {
+                                    focus: None,
+                                    button: 1,
+                                    location,
+                                };
+                                let grab = MoveGrab::new(
+                                    start_data,
+                                    active_window,
+                                    is_overview_open,
+                                    true,
+                                );
+                                self.niri.seat.get_pointer().unwrap().set_grab(
+                                    self,
+                                    grab,
+                                    SERIAL_COUNTER.next_serial(),
+                                    Focus::Clear,
+                                );
+                            }
+                        }
+                    }
                 }
+                SwipeDirection::Vertical => {
+                    self.niri.layout.overview_gesture_begin();
+                }
+                _ => {}
             }
         }
 
@@ -3847,9 +3965,8 @@ impl State {
     }
 
     fn on_gesture_swipe_end<I: InputBackend>(&mut self, event: I::GestureSwipeEndEvent) {
-        self.niri.gesture_swipe_3f_cumulative = None;
-
         let mut handled = false;
+        let serial = SERIAL_COUNTER.next_serial();
         let res = self.niri.layout.workspace_switch_gesture_end(Some(true));
         if let Some(output) = res {
             self.niri.queue_redraw(&output);
@@ -3868,12 +3985,25 @@ impl State {
             handled = true;
         }
 
+        if self.niri.gesture_swipe_3f_decider.decision == SwipeDirection::Horizontal {
+            // Call completed in [`MoveGrab`]
+            //
+            // self.niri
+            //     .seat
+            //     .get_pointer()
+            //     .unwrap()
+            //     .unset_grab(self, serial, event.time_msec());
+            handled = true;
+        }
+
+        self.niri.gesture_swipe_3f_decider = SwipeDirectionDecider::decided();
+        self.niri.gesture_swipe_4f_decider = SwipeDirectionDecider::decided();
+
         if handled {
             // We handled this event.
             return;
         }
 
-        let serial = SERIAL_COUNTER.next_serial();
         let pointer = self.niri.seat.get_pointer().unwrap();
 
         if self.update_pointer_contents() {
@@ -4106,7 +4236,9 @@ impl State {
                         location: pos,
                     };
                     let start_data = PointerOrTouchStartData::Touch(start_data);
-                    if let Some(grab) = MoveGrab::new(self, start_data, window.clone(), true) {
+                    if let Some(grab) =
+                        MoveGrab::new(self, start_data, window.clone(), true, false, false)
+                    {
                         handle.set_grab(self, grab, serial);
                     }
                 }
diff --git a/src/input/move_grab.rs b/src/input/move_grab.rs
index c78b796e..712fbe72 100644
--- a/src/input/move_grab.rs
+++ b/src/input/move_grab.rs
@@ -14,7 +14,7 @@ use smithay::input::touch::{
 };
 use smithay::input::SeatHandler;
 use smithay::output::Output;
-use smithay::utils::{IsAlive, Logical, Point, Serial};
+use smithay::utils::{IsAlive, Logical, Point, Serial, Size, SERIAL_COUNTER};
 
 use crate::input::PointerOrTouchStartData;
 use crate::niri::State;
@@ -24,9 +24,11 @@ pub struct MoveGrab {
     start_output: Output,
     start_pos_within_output: Point<f64, Logical>,
     last_location: Point<f64, Logical>,
+    swipe_location: Point<f64, Logical>,
     window: Window,
     gesture: GestureState,
     enable_view_offset: bool,
+    is_swipe_pinch: bool,
 }
 
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
@@ -42,17 +44,26 @@ impl MoveGrab {
         start_data: PointerOrTouchStartData<State>,
         window: Window,
         enable_view_offset: bool,
+        use_threshold: bool,
+        is_swipe_pinch: bool,
     ) -> Option<Self> {
         let (output, pos_within_output) = state.niri.output_under(start_data.location())?;
+        let gesture = if use_threshold {
+            GestureState::Recognizing
+        } else {
+            GestureState::Move
+        };
 
         Some(Self {
             last_location: start_data.location(),
+            swipe_location: start_data.location(),
             start_data,
             start_output: output.clone(),
             start_pos_within_output: pos_within_output,
-            window,
-            gesture: GestureState::Recognizing,
-            enable_view_offset,
+            window: window,
+            gesture: gesture,
+            enable_view_offset: enable_view_offset,
+            is_swipe_pinch: is_swipe_pinch,
         })
     }
 
@@ -94,7 +105,13 @@ impl MoveGrab {
         }
 
         // FIXME: only redraw the window output.
+
         data.niri.queue_redraw_all();
+        if !self.is_swipe_pinch {
+            data.niri
+                .cursor_manager
+                .set_cursor_image(CursorImageStatus::default_named());
+        }
     }
 
     fn begin_move(&mut self, data: &mut State) -> bool {
@@ -274,8 +291,65 @@ impl PointerGrab<State> for MoveGrab {
         _focus: Option<(<State as SeatHandler>::PointerFocus, Point<f64, Logical>)>,
         event: &MotionEvent,
     ) {
-        // While the grab is active, no client has pointer focus.
-        handle.motion(data, None, event);
+        // The pointer should not be moved by swipe and pinch gestures
+        if !self.is_swipe_pinch {
+            // While the grab is active, no client has pointer focus.
+            handle.motion(data, None, event);
+        } else if event.serial != Serial::from(0) {
+            // Ignore normal pointer motion events if we're in a swipe/pinch
+            // gesture
+            return;
+        }
+
+        if self.window.alive() {
+            if let Some((output, pos_within_output)) = data.niri.output_under(event.location) {
+                let output = output.clone();
+                let event_delta = event.location - self.last_location;
+                self.last_location = event.location;
+
+                if self.gesture == GestureState::Recognizing {
+                    let c = event.location - self.start_data.location();
+
+                    // Check if the gesture moved far enough to decide.
+                    if c.x * c.x + c.y * c.y >= 8. * 8. {
+                        self.gesture = GestureState::Move;
+
+                        if !self.is_swipe_pinch {
+                            data.niri
+                                .cursor_manager
+                                .set_cursor_image(CursorImageStatus::Named(CursorIcon::Move));
+                        }
+                    }
+                }
+
+                if self.gesture != GestureState::Move {
+                    return;
+                }
+
+                let ongoing = data.niri.layout.interactive_move_update(
+                    &self.window,
+                    event_delta,
+                    output,
+                    dbg!(pos_within_output),
+                );
+                if ongoing {
+                    // FIXME: only redraw the previous and the new output.
+                    data.niri.queue_redraw_all();
+                    return;
+                }
+            } else {
+                return;
+            }
+        }
+
+        // We asserted `event.serial == Serial::from(0)` above
+        // if `is_swipe_pinch` is true. This is not a valid serial.
+        let serial = if self.is_swipe_pinch {
+            SERIAL_COUNTER.next_serial()
+        } else {
+            event.serial
+        };
+        // The move is no longer ongoing.
 
         let timestamp = Duration::from_millis(u64::from(event.time));
         if !self.on_motion(data, event.location, timestamp) {
@@ -341,11 +415,11 @@ impl PointerGrab<State> for MoveGrab {
 
     fn gesture_swipe_begin(
         &mut self,
-        data: &mut State,
-        handle: &mut PointerInnerHandle<'_, State>,
-        event: &GestureSwipeBeginEvent,
+        _data: &mut State,
+        _handle: &mut PointerInnerHandle<'_, State>,
+        _event: &GestureSwipeBeginEvent,
     ) {
-        handle.gesture_swipe_begin(data, event);
+        // handle.gesture_swipe_begin(data, event);
     }
 
     fn gesture_swipe_update(
@@ -354,7 +428,26 @@ impl PointerGrab<State> for MoveGrab {
         handle: &mut PointerInnerHandle<'_, State>,
         event: &GestureSwipeUpdateEvent,
     ) {
-        handle.gesture_swipe_update(data, event);
+        self.swipe_location += event.delta;
+        if let Some(mut global_rect) = data.global_bounding_rectangle() {
+            // Shrink by 1 logical pixel, retaining center
+            global_rect.loc = global_rect.loc + Point::new(1, 1);
+            global_rect.size = global_rect.size - Size::new(2, 2);
+            self.swipe_location = self.swipe_location.constrain(global_rect.to_f64());
+        }
+
+        PointerGrab::motion(
+            self,
+            data,
+            handle,
+            None,
+            &MotionEvent {
+                location: self.swipe_location,
+                serial: Serial::from(0),
+                time: event.time,
+            },
+        )
+        // handle.gesture_swipe_update(data, event);
     }
 
     fn gesture_swipe_end(
@@ -363,7 +456,8 @@ impl PointerGrab<State> for MoveGrab {
         handle: &mut PointerInnerHandle<'_, State>,
         event: &GestureSwipeEndEvent,
     ) {
-        handle.gesture_swipe_end(data, event);
+        // handle.gesture_swipe_end(data, event);
+        handle.unset_grab(self, data, event.serial, event.time, true);
     }
 
     fn gesture_pinch_begin(
diff --git a/src/niri.rs b/src/niri.rs
index e59de48b..692cc1d0 100644
--- a/src/niri.rs
+++ b/src/niri.rs
@@ -134,7 +134,7 @@ use crate::input::scroll_swipe_gesture::ScrollSwipeGesture;
 use crate::input::scroll_tracker::ScrollTracker;
 use crate::input::{
     apply_libinput_settings, mods_with_finger_scroll_binds, mods_with_mouse_binds,
-    mods_with_wheel_binds, TabletData,
+    mods_with_wheel_binds, SwipeDirectionDecider, TabletData,
 };
 use crate::ipc::server::IpcServer;
 use crate::layer::mapped::LayerSurfaceRenderElement;
@@ -365,7 +365,8 @@ pub struct Niri {
     pub notified_activity_this_iteration: bool,
     pub pointer_inside_hot_corner: bool,
     pub tablet_cursor_location: Option<Point<f64, Logical>>,
-    pub gesture_swipe_3f_cumulative: Option<(f64, f64)>,
+    pub gesture_swipe_3f_decider: SwipeDirectionDecider,
+    pub gesture_swipe_4f_decider: SwipeDirectionDecider,
     pub overview_scroll_swipe_gesture: ScrollSwipeGesture,
     pub vertical_wheel_tracker: ScrollTracker,
     pub horizontal_wheel_tracker: ScrollTracker,
@@ -2786,7 +2787,9 @@ impl Niri {
             notified_activity_this_iteration: false,
             pointer_inside_hot_corner: false,
             tablet_cursor_location: None,
-            gesture_swipe_3f_cumulative: None,
+            // Will become undecided once a gesture begins
+            gesture_swipe_3f_decider: SwipeDirectionDecider::decided(),
+            gesture_swipe_4f_decider: SwipeDirectionDecider::decided(),
             overview_scroll_swipe_gesture: ScrollSwipeGesture::new(),
             vertical_wheel_tracker: ScrollTracker::new(120),
             horizontal_wheel_tracker: ScrollTracker::new(120),
-- 
2.51.2

